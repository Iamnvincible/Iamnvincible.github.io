---
layout: post
title: "数字的表示和运算 CSAPP - 1"
categories:
tags:
permalink: /10/
---

计算机最大的一个特征就是能计算，那么就会遇到“算什么”和“怎么算”的问题。
计算的对象是数字，那么在计算之前就需要将数字表示成计算机容易操作的形式。
能够想到的最基础的运算就是算术运算——加减乘除，电路能够实现算术运算，在计算机系统层面一般不去考究具体的实现方式。但电路元器件是有限的，只能表示和处理有限长度或精度的数据，我们就要在这些限制之上正确地完成计算。深入理解计算的规则，能够理解和解释编程中遇到的一些常见错误和编程疏忽导致的重大事故。

# 第二章，表示和处理信息

人类有十根手指，自然而然会用手指来完成计数，天生适合使用十进制。对于机器而言，二值信号——有和无、高和低、顺时针和逆时针等非常好区分，因而计算机更适合使用二进制。
每一个高低状态被称为 1 位（bit，比特），单个比特没有太大的用处，但将几个比特组成一组，就可以表示很多状态。一个比特只能表示高或低 2 种状态，两个比特组成在一起就能表示 4 种状态，n 个比特就可以表示 2 的 n 次方种状态。将每一种状态可以标记一个数字，这个数字就可以用来编码字母和符号。

状态的标记是一种计数方式，计数得到的是数字。数字可以是正的，也可以是负的，适当的计数方式可以表示正数和负数。进一步地，恰当的表示方式也可以高效地记录小数。计算机系统中，最重要的三种数值类型是无符号数、有符号数和浮点数。

- 无符号数（Unsigned），表示大于或等于 0 的数值。
- 有符号数（Signed），计算机系统中一般用补码（Two's-complement）来表示有符号数——正数、负数。
- 浮点数（Floating-point），是用以 2 为底的科学记数法来表示的实数。

计算机系统中，使用有限的比特来编码一个数字，所以能够编码的数字是有范围的，如果经过加减乘除后的结果超出了编码能够表示的范围，就会产生溢出（overflow），这也是一些错误产生的根源。

> 计算机的整数法算术运算也满足*交换律*和*结合律*，虽然几个因数相乘的积可能溢出而得到一个负数，但通过交换或结合的方式修改表达式执行的次序，得到的结果相同。
> 计算机的浮点数运算就没有这么和谐了。浮点数运算没有结合性，因为浮点数只能表示有限的精度，改变运算次序可能会丢失精度而造成两种计算方式结果不一致。

无符号数和有符号数可以统称为整数，整数能够表示的范围有限，但计算结果相对准确；浮点数能够在与整数使用相同数量比特编码条件下，表示更大范围的数值，但结果可能不精确，是一个近似值。

计算机可以采用不止一种编码数字的规则，运算也不局限于对单个数字，也可以操作表示这个数字的编码。

## 信息的存储

信息由比特组成，但计算机访问信息时通常以 8 位比特作为一组来访问，每 8 位比特组成一个字节（byte），字节是内存中可寻址的最小单元。对于机器来说，内存就是一块很大的字节数组，或称为虚拟内存（virtual memory）。每一个字节都由一个唯一的数字标志，这个数字就是这个字节的地址。程序能访问的整块内存地址的集合称为虚拟地址空间（virtual address space）。之所以称作“虚拟”，是因为这块内存空间是一个程序逻辑上的映像，这块空间实际可以映射到物理内存（DRAM）、磁盘或其他硬件设备，这是操作系统为程序提供的一个看上去庞大而又连续的字节数组，并非所有地址都可使用。在程序运行时，虚拟地址空间会被分成几个部分以便于管理。C 语言中的指针的值就表示一个内存地址，类型系统会将指针指向特定类型数据的第一个字节的地址

### 十六进制记法

1 个字节的 8 个比特用二进制表示，其值为 `00000000` 至 `11111111`，对应十进制为 0 到 255。很多时候，用二进制表示一个数字会显得十分冗长，而用十进制表示就不能快速对应比特值。在程序代码中通常会使用十六进制表示一些数值，十六进制记法显得简洁而又能够快速对应数值中的每一个比特。一个字节的范围用十六进制表示就是 `00` 到 `FF`，每一个十六进制符号都对应 4 个二进制值。

当一个整数刚好是 2 的 n 次方时，其二进制记法就是 1 后面加 n 个 0。由于 4 个 0 对应一个十六进制的 0，可以快速将后面的 0 转为十六进制，记 $$n = i + 4j,\quad0\le i \le 3$$。$$j$$ 表示十六进制 0 的个数，$$i$$ 的值可以对应十六进制值的最高位，0 对应 1 ，1 对应 2，2 对应 4，3 对应 8。例如，2048 是 2 的 11 次方，$$ n = 11 = 3 + 4\times2$$，将其转成十六进制就是 `0x800`。

将十进制数转到十六进制数，只要将十进制数连续除以 16 并取余，直到商为 0。先得到的余数写在低位，后得到的写在高位。将较大的十进制数转换到十六进制时，可以求助搜索引擎，例如，“123 in hex”。

### 数据长度

字长，是计算机的一个重要参数。字长表示指针的长度（更准确地说，字长是 CPU 一次可以处理数据的最大长度），指针代表了一块数据所在的内存地址，编码虚拟地址空间大小的数据长度也是一个字长，所以字长决定了程序可寻址空间的大小，也决定了主存能使用的最大空间。对于 32 位字长的机器，虚拟地址最大 2^32 字节，也就是 4 GB，64 位则高达 16 EB。

64 位的计算机也可以运行为 32 位机器编译的程序，这种兼容性称为**后向兼容**（backward compatibility）。`gcc -m32 prog.c` 这条指令可以编译出 32 位的程序，该程序可以顺利地运行在 32 位和 64 位计算机上。而 `gcc -m64 prog.c` 指令编译出的程序不能在 32 位计算机上运行，只能在 64 位计算机上运行（如果有了 128 位计算机，应该也能在这上面运行。这里指的是在同一架构下的程序）。程序是 32 位或 64 位与运行的机器的字长无关，只与编译这个程序时指定的目标字长有关。

C 语言中的整数和浮点数都可以根据精度需要使用不同的长度来编码。每种类型的数据，在不同的平台上占用的长度并不一定相同，具体由编译平台确定。典型的 32 位和 64 位程序中，`int` 类型都会占用 4 字节空间，`long` 类型分别占用 4 字节和 8 字节。为了避免相同类型在不同编译器下使用不同的类型长度，ISO C99 规定了固定长度的类型。例如，显式使用 `int32_t` 和 `int64_t` 类型会告诉编译器使用确定的 4 字节和 8 字节来编码对应整数。在不指明类型是否是有符号数时，默认都采用有符号 `signed` 关键字修饰，除非显式指定 `unsigned` 关键字。

对程序员来说，要确保程序在不同机器上有相同的表现，可以移植到不同机器上使用，不依赖于平台和编译器。例如，在 32 位机器比较主流的年代，程序员只需要使用 `int` 类型就可以存储指针；而在迁移到 64 位平台后，`int` 类型将不足以存放指针类型。

### 寻址和字节序

当数据对象会使用多个字节来编码时，需要建立两项约定才能让代码在不同机器间有相同表现。

1. 对象地址的表示方式；
2. 内存中字节的排列次序（字节序）。

绝大部分机器上，一个占用多个字节的类型对象都会占用连续的地址空间，对象的地址就是这块连续地址空间的最小地址。以一个 32 位长度的 `int` 类型数字为例，如果变量 `x` 的地址是 `0x100`，这就是说，`&x` 的值是 `0x100`。因为这个类型有 4 个字节，它占用的 4 个内存地址就是 `0x100`，`0x101`，`0x102`，`0x103`。每个地址对应的空间中存放一个字节的数据，为了读出这个整数所表示的具体值，有两种不同的读数约定。

如果一个整数用 $$\omega$$ 位表示，可以用 $$\left[x_{\omega-1},x_{\omega-2},\cdots,x_1,x_0\right]$$ 表示其中的每一位值。那么 $$x_{\omega-1}$$ 就是这个数的最高位，$$x_{0}$$ 是最低位。假定 $$\omega$$ 是 8 的倍数，那么将这些比特按字节分组，可以得到若干组，最高位所在的字节组可以称作*最高字节*，最低位所在的字节组称作*最低字节*，其他组在中间。

一些机器将整数的最高字节放在占用内存的最小地址中，最低字节放在最大地址中，这种字节序称为**大端字节序**（little endian）。另一些机器则按相反的次序存放，称为**小端字节序**（big edian）。大小端名称取自《格列佛游记》故事中，敲鸡蛋从大的一端敲还是小的一端敲。

对于特定的机器来说，一旦操作系统确定，系统使用的字节序也确定了。大多数程序不需要考虑字节序问题，只有在程序需要通过网络向其他计算机发送数据时才需要考虑字节序问题。为了避免不同计算机之间字节序不同产生的问题，在网络编程中规定，**在网络上传输的数据必须采用大端字节序**，接收方根据需要转换成本机使用的字节序。

除此之外，在使用反汇编器读取二进制程序中的机器指令时也需要考虑字节序问题。目标二进制程序的大小端会影响反汇编器生成汇编代码的结果。

在 C 语言中，规避类型系统时，也会因不同机器的字节序差异而得到不同的结果。把任意 C 语言中的类型转换成 `unsigned char` 类型后，依次打印一个字节，就可以看到这个类型中按地址从低到高顺序存放的值。下面的代码可以将一个整形从低地址开始打印占用的每一个字节中的数据。使用 `sizeof` 操作符获取类型占用的字节数是个好习惯，它能够得到类型在实际运行平台上占用的字节数，能够帮助代码实现跨平台。

```c
#include <stdio.h>

typedef unsigned char *byte_pointer;

void show_bytes(byte_pointer start, size_t len) {
    int i;
    for (i = 0; i < len; i++)
        printf(" %.2x", start[i]);
    printf("\n");
}

void show_int(int x) {
    show_bytes((byte_pointer) &x, sizeof(int));
}
```

### 表示字符串和代码
C 语言中的字符串是以空（`NULL`）为终止的字符数组。字符和值的关系参照 ASCII 码表。

对于程序源代码文件来说，其中保存的也是字符串。在不同平台上源代码文件不会改变，而当源代码被编译成特定平台上的可执行文件后，可执行文件中的内容会大不相同。可执行文件中不会保留源代码中的信息，只按特定平台的机器指令规则生成。不同平台使用的机器指令不兼容，也采用不同的编码方式。即使是同一个处理器上运行的不同操作系统之间，指令编码约定都可能不同。因此，二进制程序一般不能在不同机器、操作系统上兼容运行。

### 布尔代数
二进制值能够很好地在计算机上存储和处理，布尔代数将 0 和 1 解释为逻辑上的“真”和“假”，为计算扩展了一大步。在 C 语言中，定义了 4 中布尔代数，分别是：
- 取反，符号 `~`，对应逻辑操作 `NOT`。
- 与，符号 `&`，对应逻辑操作 `AND`。
- 或，符号 `|`，对应逻辑操作 `OR`。
- 异或，符号 `^`，对应逻辑操作 `EXCLUSIVE-OR`。

布尔代数是对单个逻辑值的计算，我们可以将计算扩展到一组比特之上，同时对一组比特做逻辑计算。这一组比特可以称作位向量，向量中包含 0 和 1 的序列，长度固定为 $$\omega$$。

> 信息论创始人香农（Claude Shannon）首次将布尔代数和数字逻辑联系起来。1937 年，21 岁的香农在他的硕士论文中提出，将布尔代数应用于电子领域，能够构建并解决任何逻辑和数值关系。

布尔代数与算术运算又很多相同之处，但也有不同。例如，乘法对加法有分配律，`&` 对 `|` 也有分配律；反过来，`|` 对 `&` 也有分配律，这和算术运算不同。有 `a&(b|c)=(a&b)|(a&c)` 和 `a|(b&c)=(a|b)&(a|c)`。对于 `^`、`&` 和 `~` 三种位向量上的运算，满足布尔环这一数学形式。布尔环与算术运算有一些相同的特性，例如，每个元素 `x` 都有其加法逆元 `-x`，满足 `x + -x = 0`。`^` 运算类似于加法，对每个元素也有对应的“加法逆元”，只不过其加法逆元是其本身，即 `a ^ a = 0`。此外，`^` 运算也满足交换律和结合律，也就是异或运算中的元素可以交换顺序，所以 `(a^b)^a = b`。

### C 语言中的位运算
C 语言支持位运算，实质是对每一个比特做布尔运算。在做位运算时，最好将数字转换为二进制。

利用上面异或的“加法逆元”或称相反数是其本身的性质，可以写出不使用临时变量交换两个数值得函数。
```c
void inplace_swap(int *x, int *y) {
    *y = *x ^ *y; /* Step 1 */
    *x = *x ^ *y; /* Step 2 */
    *y = *x ^ *y; /* Step 3 */
}
```

位运算通常用来实现掩码操作，掩码是一个若干比特组成的模式，用于从一个字中选择或操作特定的比特。例如模式 `0xFF` 表示一个字中的最低一个字节。位运算 `x & 0xFF` 会将 `x` 的最低一个字节选中，并将其他比特置为 0。`~0` 会将所有比特置为 1，无论数据的字长是多少字节，而如果用 `0xFFFFFFFF` 来表示全 1，只能在 `int` 是 32 位的时候有效，不够通用。

位运算的使用非常需要技巧，技巧的掌握在于充分理解每种位运算的特点。这种技巧就像学习了二叉树的若干特点之后，要在这棵树上完成一些令人眼花缭乱的操作，最后实现一个巧妙而高效的算法。
在本章后面有很多位运算练习，可以帮助理解位运算。一些问题可能不用位运算也能解决，而且代码可读性更好。位运算的好处在于，用更少的空间更快地完成计算。

这里列举几个看似简单但在应用时不容易想到的规则：
- `x^0 = x`
- `x^(~0) = ~x`

### C 语言中的逻辑运算

逻辑运算有三种：
- 与，符号 `&&`。
- 或，符号 `||`。
- 非，符号 `!`。
  
逻辑运算与位运算有所不同，位运算操作的数值中的比特值，而逻辑运算将数值整体解释为“真”或“假”——所有非零数解释为“真”，零解释为“假”，运算的结果也只有“真”、“假”两种。在对逻辑运算结果取值时，结果为“真”时，值为 1；结果为“假”时，值为 0。
逻辑运算可以看作是位运算在参数值限制在 0 或 1 时的特殊情况。另外，参与位运算的每个数都要经过运算，而逻辑运算存在“懒惰求值”的特点，即在逻辑“与”和“或”运算时，不一定要将每个参数求值。
逻辑运算与位运算一样具有一定技巧性，例如，`x == y` 可以用逻辑运算 `!(x^y)` 代替。

### C 语言中的移位运算
- 左移（left shift）。`x << k`，会将 x 的高 k 位移出，右边移入 k 位 0。k 的值必须小于 x 的位数，同时不为负数。连续多次移位可以应用交换律。
- 右移（right shift）。左移易于理解，而右移有两种，逻辑（Logical）右移和算术（Arithmetic）右移，这是因为要考虑数值的符号位。
  - 逻辑右移。与左移类似，高位移入 k 位 0，低位移出 k 位。
  - 算术右移。高位移入的 k 位数字与原数最高位相同，低位移出 k 位。算术右移能保留有符号整数的符号位。

需要注意的是，C 标准并没有明确规定右移使用逻辑右移还是算术右移，这意味着假定右移方式的代码可能会遇到兼容性问题。不过，在实际中，几乎所有的编译器和计算机的组合都对有符号整数才有算术右移。另外，无符号整数的右移*一定*是逻辑右移。